/**
 * Route Group Template Generator
 *
 * This module generates route group classes that contain typed methods
 * for each API endpoint in a logical group.
 */

import { RouteGroup, ParsedOperation } from '../parsers/route-parser';
import { toPascalCase } from '../utils/naming.js';
import { extractTypeNamesForOperations } from '../parsers/openapi-parser.js';

/**
 * Configuration for route group generation
 */
interface RouteGroupGenerationOptions {
  /** Path to types file generated by openapi-typescript */
  typesFile?: string | undefined;
  /** Original OpenAPI specification (before dereferencing) for per-group type extraction */
  originalSpec?: any;
  /** Map from "path:method" to response type name (extracted before dereferencing) */
  responseTypeMapping?: Map<string, string> | undefined;
}

/**
 * Generate route group classes for all groups
 *
 * @param routeGroups - Array of route groups
 * @param options - Generation options
 * @returns Map of group name to generated class code
 */
export function generateRouteGroups(
  routeGroups: RouteGroup[],
  options: RouteGroupGenerationOptions
): Record<string, string> {
  const generatedGroups: Record<string, string> = {};

  for (const group of routeGroups) {
    generatedGroups[group.name] = generateRouteGroupClass(group, options);
  }

  return generatedGroups;
}

/**
 * Generate a single route group class
 *
 * @param group - Route group to generate
 * @param options - Generation options
 * @returns Generated class code
 */
function generateRouteGroupClass(group: RouteGroup, options: RouteGroupGenerationOptions): string {
  const { typesFile, originalSpec, responseTypeMapping } = options;

  // Extract type names only for this route group's operations
  const typeNames = originalSpec
    ? extractTypeNamesForOperations(
        originalSpec,
        group.operations.map(op => ({ path: op.path, method: op.method }))
      )
    : undefined;

  const imports = generateRouteGroupImports(typesFile);
  const typeAliases = typesFile ? generateTypeAliases(group, typeNames) : '';
  const classDoc = generateRouteGroupJSDoc(group);
  const constructor = generateRouteGroupConstructor(group.className);
  const methods = generateRouteGroupMethods(group.operations, typeNames, responseTypeMapping);
  const classBody = generateRouteGroupClassBody(group.className, constructor, methods);

  return `${imports}
${typeAliases}
${classDoc}
${classBody}`;
}

/**
 * Generate imports for a route group
 */
function generateRouteGroupImports(typesFile?: string): string {
  const imports = ["import { HttpClient } from '@reggieofarrell/http-client';"];

  // Import generated types from components schemas
  if (typesFile) {
    imports.push("import type { components } from '../types';");
  }

  return imports.join('\n');
}

/**
 * Generate type aliases from components.schemas
 *
 * @param group - Route group to generate aliases for
 * @param providedTypeNames - Optional set of type names to use directly (extracted before dereferencing)
 * @returns Generated type alias code
 */
function generateTypeAliases(group: RouteGroup, providedTypeNames?: Set<string>): string {
  // If type names are provided (extracted before dereferencing), use them directly
  if (providedTypeNames && providedTypeNames.size > 0) {
    const aliases = Array.from(providedTypeNames).map(
      typeName => `type ${toPascalCase(typeName)} = components['schemas']['${typeName}'];`
    );
    return `\n${aliases.join('\n')}\n`;
  }

  // Fallback to existing extraction logic (for backward compatibility)
  // This won't work for dereferenced schemas, but preserves existing behavior
  const typeNames = new Set<string>();

  // Collect all type names used in this route group
  for (const operation of group.operations) {
    // Request body types
    if (operation.requestBody?.schema) {
      const typeName = extractTypeNameFromSchema(operation.requestBody.schema);
      if (typeName) typeNames.add(typeName);
    }

    // Response types
    for (const response of operation.responses) {
      if (response.schema) {
        const typeName = extractTypeNameFromSchema(response.schema);
        if (typeName) typeNames.add(typeName);
      }
    }
  }

  if (typeNames.size === 0) return '';

  const aliases = Array.from(typeNames).map(
    typeName => `type ${toPascalCase(typeName)} = components['schemas']['${typeName}'];`
  );

  return `\n${aliases.join('\n')}\n`;
}

/**
 * Extract type name from a schema reference
 */
function extractTypeNameFromSchema(schema: any): string | null {
  if (schema.$ref) {
    const refParts = schema.$ref.split('/');
    return refParts[refParts.length - 1];
  }

  if (schema.type === 'array' && schema.items?.$ref) {
    return extractTypeNameFromSchema(schema.items);
  }

  return null;
}

/**
 * Generate JSDoc for a route group class
 */
function generateRouteGroupJSDoc(group: RouteGroup): string {
  const methodList = group.operations
    .map(op => ` * - ${op.methodName}() - ${op.method} ${op.path}`)
    .join('\n');

  return `/**
 * ${group.displayName} Route Group
 *
 * Provides typed methods for ${group.displayName.toLowerCase()} operations:
${methodList}
 *
 * @example
 * \`\`\`typescript
 * // Get a user by ID
 * const user = await client.${group.name}.getUser({ id: '123' });
 *
 * // Create a new user
 * const newUser = await client.${group.name}.createUser({
 *   name: 'John Doe',
 *   email: 'john@example.com'
 * });
 * \`\`\`
 */`;
}

/**
 * Generate constructor for a route group
 */
function generateRouteGroupConstructor(className: string): string {
  return `  /**
   * Create a new ${className} instance
   *
   * @param client - HttpClient instance for making requests
   */
  constructor(private client: HttpClient) {}`;
}

/**
 * Generate methods for all operations in a route group
 */
function generateRouteGroupMethods(
  operations: ParsedOperation[],
  typeNames?: Set<string>,
  responseTypeMapping?: Map<string, string>
): string {
  return operations
    .map(operation => generateMethod(operation, typeNames, responseTypeMapping))
    .join('\n\n');
}

/**
 * Generate a single method for an operation
 */
function generateMethod(
  operation: ParsedOperation,
  typeNames?: Set<string>,
  responseTypeMapping?: Map<string, string>
): string {
  const methodDoc = generateMethodJSDoc(operation);
  const methodSignature = generateMethodSignature(operation, typeNames, responseTypeMapping);
  // Extract return type from the method signature to use in method body
  const returnTypeMatch = methodSignature.match(/Promise<([^>]+)>/);
  const returnType = returnTypeMatch ? returnTypeMatch[1] : 'any';
  const methodBody = generateMethodBody(operation, returnType);

  return `${methodDoc}
  ${methodSignature} {
${methodBody}
  }`;
}

/**
 * Generate JSDoc for a method
 */
function generateMethodJSDoc(operation: ParsedOperation): string {
  const { method, path, methodName, pathParams, queryParams, requestBody, responses } = operation;

  const params = [
    ...pathParams.map(param => `   * @param pathParams.${param.name} - ${param.name} parameter`),
    ...queryParams.map(param => `   * @param query.${param.name} - ${param.name} query parameter`),
  ];

  if (requestBody) {
    params.push(`   * @param body - Request body`);
  }

  const returnType = responses.find(r => r.statusCode.startsWith('2'))?.schema
    ? 'Response data'
    : 'Response data';

  return `  /**
   * ${methodName} - ${method} ${path}
   *
${params.join('\n')}
   * @returns Promise resolving to ${returnType}
   */`;
}

/**
 * Generate method signature
 */
function generateMethodSignature(
  operation: ParsedOperation,
  typeNames?: Set<string>,
  responseTypeMapping?: Map<string, string>
): string {
  const { methodName, method, path, pathParams, queryParams, requestBody, responses } = operation;

  const params: string[] = [];

  // Add path parameters
  if (pathParams.length > 0) {
    const pathParamTypes = pathParams.map(
      param => `${param.name}: ${param.type}${param.required ? '' : '?'}`
    );
    params.push(`pathParams: { ${pathParamTypes.join(', ')} }`);
  }

  // Add query parameters
  if (queryParams.length > 0) {
    const queryParamTypes = queryParams.map(
      param => `${param.name}${param.required ? '' : '?'}: ${param.type}`
    );
    if (params.length > 0) {
      params[0] += `, query?: { ${queryParamTypes.join(', ')} }`;
    } else {
      params.push(`query?: { ${queryParamTypes.join(', ')} }`);
    }
  }

  // Add request body
  if (requestBody) {
    const bodyType = requestBody.schema
      ? getSchemaTypeName(requestBody.schema, false, typeNames)
      : 'any';
    params.push(`body: ${bodyType}`);
  }

  // Determine return type
  // First try to get from response type mapping (extracted before dereferencing)
  const operationKey = `${path}:${method}`;
  let returnType = 'any';

  if (responseTypeMapping?.has(operationKey)) {
    const typeName = responseTypeMapping.get(operationKey)!;
    // Handle special marker for void return type (204 No Content)
    if (typeName === '__void__') {
      returnType = 'void';
    } else {
      returnType = toPascalCase(typeName);
    }
  } else {
    // Fallback to extracting from dereferenced schema
    const successResponse = responses.find(r => r.statusCode.startsWith('2'));
    if (successResponse?.schema) {
      returnType = getSchemaTypeName(successResponse.schema, false, typeNames);
    } else {
      returnType = 'any';
    }
  }

  const paramString = params.length > 0 ? params.join(', ') : '';

  return `async ${methodName}(${paramString}): Promise<${returnType}>`;
}

/**
 * Generate method body
 *
 * @param operation - Parsed operation
 * @param returnType - Return type extracted from method signature
 */
function generateMethodBody(operation: ParsedOperation, returnType: string): string {
  const { method, path, pathParams, queryParams, requestBody } = operation;

  // Convert OpenAPI {param} format to HttpClient :param format
  let urlTemplate = path;
  for (const param of pathParams) {
    urlTemplate = urlTemplate.replace(`{${param.name}}`, `:${param.name}`);
  }

  // Build request config options
  const configOptions: string[] = [];
  if (pathParams.length > 0) {
    configOptions.push('pathParams: pathParams');
  }
  if (queryParams.length > 0) {
    configOptions.push('query: query');
  }
  if (requestBody) {
    configOptions.push('data: body');
  }

  const optionsString = configOptions.length > 0 ? `, { ${configOptions.join(', ')} }` : '';

  // Generate the request call using the return type from method signature
  const methodLower = method.toLowerCase();
  const requestCall = `this.client.${methodLower}<${returnType}>(\`${urlTemplate}\`${optionsString})`;

  // Build the method body
  // For void return types (204 No Content), don't return data
  if (returnType === 'void') {
    return `    await ${requestCall};`;
  }

  return `    return (await ${requestCall}).data;`;
}

/**
 * Generate the complete route group class body
 */
function generateRouteGroupClassBody(
  className: string,
  constructor: string,
  methods: string
): string {
  return `export class ${className} {
${constructor}

${methods}
}`;
}

/**
 * Extract type name from schema reference or object
 *
 * @param schema - Schema object (may be dereferenced)
 * @param useComponentsNamespace - Whether to use components['schemas'] syntax
 * @param typeNames - Optional set of known type names (extracted before dereferencing)
 * @returns TypeScript type name
 */
function getSchemaTypeName(
  schema: any,
  useComponentsNamespace: boolean = false,
  typeNames?: Set<string>
): string {
  if (schema.$ref) {
    // Extract type name from $ref like "#/components/schemas/User"
    const refParts = schema.$ref.split('/');
    const typeName = refParts[refParts.length - 1];

    // Use components.schemas namespace if types are generated, otherwise use PascalCase
    return useComponentsNamespace ? `components['schemas']['${typeName}']` : toPascalCase(typeName);
  }

  // For array schemas, prefer title if available (e.g., "Patch Request" -> "PatchRequest[]")
  // Otherwise, use the items type
  if (schema.type === 'array') {
    // If schema has a title, use it for the array type name
    if (schema.title) {
      const cleanedTitle = schema.title.replace(/[.,;:!?]+$/, '').trim();
      return `${toPascalCase(cleanedTitle)}[]`;
    }

    // Otherwise, derive from items
    if (schema.items?.$ref) {
      const itemType = getSchemaTypeName(schema.items, useComponentsNamespace, typeNames);
      return `${itemType}[]`;
    }

    if (schema.items) {
      // Handle array of inline schemas
      const itemType = getSchemaTypeName(schema.items, useComponentsNamespace, typeNames);
      return `${itemType}[]`;
    }
  }

  // For dereferenced schemas without $ref, try to match by title
  // Check if schema title matches a known type name (with various formatting)
  if (schema.title && typeNames && typeNames.size > 0) {
    const cleanedTitle = schema.title.replace(/[.,;:!?]+$/, '').trim();
    const titleSnakeCase = cleanedTitle.toLowerCase().replace(/\s+/g, '_');

    // Check if title matches any type name (check both snake_case and PascalCase variants)
    for (const typeName of typeNames) {
      const typeNamePascalCase = toPascalCase(typeName);
      // Check if title matches type name as PascalCase
      if (typeNamePascalCase === cleanedTitle) {
        return useComponentsNamespace ? `components['schemas']['${typeName}']` : typeNamePascalCase;
      }
      // Also check snake_case variants
      if (typeName === titleSnakeCase) {
        return useComponentsNamespace ? `components['schemas']['${typeName}']` : typeNamePascalCase;
      }
    }
  }

  // For inline schemas, try to generate a meaningful type name from title
  if (schema.title) {
    // Clean trailing punctuation from title (e.g., "Order Tracker Request." -> "OrderTrackerRequest")
    const cleanedTitle = schema.title.replace(/[.,;:!?]+$/, '').trim();

    // If title is already in PascalCase (starts with uppercase, has uppercase letters inside),
    // use it directly. Otherwise, convert it.
    const isAlreadyPascalCase = /^[A-Z][a-zA-Z0-9]*$/.test(cleanedTitle);
    if (isAlreadyPascalCase) {
      return cleanedTitle;
    }

    return toPascalCase(cleanedTitle);
  }

  // For inline schemas, return a generic type
  return 'any';
}
