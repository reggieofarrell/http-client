/**
 * Route Group Template Generator
 *
 * This module generates route group classes that contain typed methods
 * for each API endpoint in a logical group.
 */

import { RouteGroup, ParsedOperation } from '../parsers/route-parser';

/**
 * Configuration for route group generation
 */
interface RouteGroupGenerationOptions {
  /** Path to types file generated by openapi-typescript */
  typesFile?: string | undefined;
}

/**
 * Generate route group classes for all groups
 *
 * @param routeGroups - Array of route groups
 * @param options - Generation options
 * @returns Map of group name to generated class code
 */
export function generateRouteGroups(
  routeGroups: RouteGroup[],
  options: RouteGroupGenerationOptions
): Record<string, string> {
  const generatedGroups: Record<string, string> = {};

  for (const group of routeGroups) {
    generatedGroups[group.name] = generateRouteGroupClass(group, options);
  }

  return generatedGroups;
}

/**
 * Generate a single route group class
 *
 * @param group - Route group to generate
 * @param options - Generation options
 * @returns Generated class code
 */
function generateRouteGroupClass(group: RouteGroup, options: RouteGroupGenerationOptions): string {
  const { typesFile } = options;

  const imports = generateRouteGroupImports(typesFile);
  const typeAliases = typesFile ? generateTypeAliases(group) : '';
  const classDoc = generateRouteGroupJSDoc(group);
  const constructor = generateRouteGroupConstructor(group.className);
  const methods = generateRouteGroupMethods(group.operations, typesFile);
  const classBody = generateRouteGroupClassBody(group.className, constructor, methods);

  return `${imports}
${typeAliases}
${classDoc}
${classBody}`;
}

/**
 * Generate imports for a route group
 */
function generateRouteGroupImports(typesFile?: string): string {
  const imports = ["import { HttpClient } from '@reggieofarrell/http-client';"];

  // Import generated types from components schemas
  if (typesFile) {
    imports.push("import type { components } from '../types';");
  }

  return imports.join('\n');
}

/**
 * Generate type aliases from components.schemas
 */
function generateTypeAliases(group: RouteGroup): string {
  const typeNames = new Set<string>();

  // Collect all type names used in this route group
  for (const operation of group.operations) {
    // Request body types
    if (operation.requestBody?.schema) {
      const typeName = extractTypeNameFromSchema(operation.requestBody.schema);
      if (typeName) typeNames.add(typeName);
    }

    // Response types
    for (const response of operation.responses) {
      if (response.schema) {
        const typeName = extractTypeNameFromSchema(response.schema);
        if (typeName) typeNames.add(typeName);
      }
    }
  }

  if (typeNames.size === 0) return '';

  const aliases = Array.from(typeNames).map(
    typeName => `type ${typeName} = components['schemas']['${typeName}'];`
  );

  return `\n${aliases.join('\n')}\n`;
}

/**
 * Extract type name from a schema reference
 */
function extractTypeNameFromSchema(schema: any): string | null {
  if (schema.$ref) {
    const refParts = schema.$ref.split('/');
    return refParts[refParts.length - 1];
  }

  if (schema.type === 'array' && schema.items?.$ref) {
    return extractTypeNameFromSchema(schema.items);
  }

  return null;
}

/**
 * Generate JSDoc for a route group class
 */
function generateRouteGroupJSDoc(group: RouteGroup): string {
  const methodList = group.operations
    .map(op => ` * - ${op.methodName}() - ${op.method} ${op.path}`)
    .join('\n');

  return `/**
 * ${group.displayName} Route Group
 *
 * Provides typed methods for ${group.displayName.toLowerCase()} operations:
${methodList}
 *
 * @example
 * \`\`\`typescript
 * // Get a user by ID
 * const user = await client.${group.name}.getUser({ id: '123' });
 *
 * // Create a new user
 * const newUser = await client.${group.name}.createUser({
 *   name: 'John Doe',
 *   email: 'john@example.com'
 * });
 * \`\`\`
 */`;
}

/**
 * Generate constructor for a route group
 */
function generateRouteGroupConstructor(className: string): string {
  return `  /**
   * Create a new ${className} instance
   *
   * @param client - HttpClient instance for making requests
   */
  constructor(private client: HttpClient) {}`;
}

/**
 * Generate methods for all operations in a route group
 */
function generateRouteGroupMethods(operations: ParsedOperation[], typesFile?: string): string {
  return operations.map(operation => generateMethod(operation, typesFile)).join('\n\n');
}

/**
 * Generate a single method for an operation
 */
function generateMethod(operation: ParsedOperation, typesFile?: string): string {
  const methodDoc = generateMethodJSDoc(operation);
  const methodSignature = generateMethodSignature(operation);
  const methodBody = generateMethodBody(operation, typesFile);

  return `${methodDoc}
  ${methodSignature} {
${methodBody}
  }`;
}

/**
 * Generate JSDoc for a method
 */
function generateMethodJSDoc(operation: ParsedOperation): string {
  const { method, path, methodName, pathParams, queryParams, requestBody, responses } = operation;

  const params = [
    ...pathParams.map(param => `   * @param params.${param.name} - ${param.name} parameter`),
    ...queryParams.map(param => `   * @param params.${param.name} - ${param.name} query parameter`),
  ];

  if (requestBody) {
    params.push(`   * @param body - Request body`);
  }

  const returnType = responses.find(r => r.statusCode.startsWith('2'))?.schema
    ? 'Response data'
    : 'Response data';

  return `  /**
   * ${methodName} - ${method} ${path}
   *
${params.join('\n')}
   * @returns Promise resolving to ${returnType}
   */`;
}

/**
 * Generate method signature
 */
function generateMethodSignature(operation: ParsedOperation): string {
  const { methodName, pathParams, queryParams, requestBody, responses } = operation;

  const params: string[] = [];

  // Add path parameters
  if (pathParams.length > 0) {
    const pathParamTypes = pathParams.map(
      param => `${param.name}: ${param.type}${param.required ? '' : '?'}`
    );
    params.push(`params: { ${pathParamTypes.join(', ')} }`);
  }

  // Add query parameters
  if (queryParams.length > 0) {
    const queryParamTypes = queryParams.map(
      param => `${param.name}: ${param.type}${param.required ? '' : '?'}`
    );
    if (params.length > 0) {
      params[0] += `, query?: { ${queryParamTypes.join(', ')} }`;
    } else {
      params.push(`query?: { ${queryParamTypes.join(', ')} }`);
    }
  }

  // Add request body
  if (requestBody) {
    const bodyType = requestBody.schema ? getSchemaTypeName(requestBody.schema) : 'any';
    params.push(`body: ${bodyType}`);
  }

  // Determine return type
  const successResponse = responses.find(r => r.statusCode.startsWith('2'));
  const returnType = successResponse?.schema ? getSchemaTypeName(successResponse.schema) : 'any';

  const paramString = params.length > 0 ? params.join(', ') : '';

  return `async ${methodName}(${paramString}): Promise<${returnType}>`;
}

/**
 * Generate method body
 */
function generateMethodBody(operation: ParsedOperation, typesFile?: string): string {
  const { method, path, pathParams, queryParams, requestBody } = operation;

  // Build the URL with path parameters
  let url = path;
  for (const param of pathParams) {
    url = url.replace(`{${param.name}}`, `\${params.${param.name}}`);
  }

  // Build query string
  let queryString = '';
  if (queryParams.length > 0) {
    const queryPairs = queryParams.map(
      param => `query?.${param.name} ? \`${param.name}=\${query.${param.name}}\` : ''`
    );
    queryString = `\n    const queryString = [${queryPairs.join(', ')}].filter(Boolean).join('&');\n    const fullUrl = queryString ? \`\${url}?\${queryString}\` : url;`;
  } else {
    // If no query params, just use the URL directly
    queryString = `\n    const fullUrl = \`${url}\`;`;
  }

  // Build request options
  const requestOptions: string[] = [];
  if (requestBody) {
    requestOptions.push('data: body');
  }

  const optionsString = requestOptions.length > 0 ? `, { ${requestOptions.join(', ')} }` : '';

  // Determine return type for the request call
  const successResponse = operation.responses.find(r => r.statusCode.startsWith('2'));
  const returnType = successResponse?.schema ? getSchemaTypeName(successResponse.schema) : 'any';

  // Generate the request call
  const methodLower = method.toLowerCase();
  const requestCall = queryString
    ? `this.client.${methodLower}<${returnType}>(fullUrl${optionsString})`
    : `this.client.${methodLower}<${returnType}>(\`${url}\`${optionsString})`;

  // Add type imports if available
  let typeCode = '';
  if (typesFile) {
    typeCode = `
    // Types are available from openapi-typescript`;
  }

  return `    try {${typeCode}${queryString}
      const { data } = await ${requestCall};
      return data;
    } catch (error) {
      throw error;
    }`;
}

/**
 * Generate the complete route group class body
 */
function generateRouteGroupClassBody(
  className: string,
  constructor: string,
  methods: string
): string {
  return `export class ${className} {
${constructor}

${methods}
}`;
}

/**
 * Extract type name from schema reference or object
 */
function getSchemaTypeName(schema: any, useComponentsNamespace: boolean = false): string {
  if (schema.$ref) {
    // Extract type name from $ref like "#/components/schemas/User"
    const refParts = schema.$ref.split('/');
    const typeName = refParts[refParts.length - 1];

    // Use components.schemas namespace if types are generated
    return useComponentsNamespace ? `components['schemas']['${typeName}']` : typeName;
  }

  if (schema.type === 'array' && schema.items?.$ref) {
    const itemType = getSchemaTypeName(schema.items, useComponentsNamespace);
    return `${itemType}[]`;
  }

  // For inline schemas, return a generic type
  return 'any';
}
