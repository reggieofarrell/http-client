/**
 * Main code generation interface
 *
 * This module provides the primary API for generating SDK clients from OpenAPI specifications.
 * Uses openapi-typescript for type generation and focuses on SDK client structure.
 */

import openapiTS, { astToString } from 'openapi-typescript';
import { join } from 'path';
import { promises as fs } from 'fs';
import {
  parseOpenApiSpec,
  detectErrorMessagePath,
  extractResponseTypeMapping,
} from './parsers/openapi-parser.js';
import { parseRoutes } from './parsers/route-parser.js';
import { generateClientClass } from './templates/client-template.js';
import { generateRouteGroups } from './templates/route-group-template.js';
import { extractCustomErrorSchemas, generateErrorTypes } from './templates/error-template.js';
import { writeGeneratedFiles } from './utils/file-writer.js';

/**
 * Configuration options for client generation
 */
export interface GenerateClientOptions {
  /** OpenAPI specification - can be a file path or parsed object */
  openApiSpec: string | object;
  /** Directory where generated files will be written */
  outputDir: string;
  /** Override the default client name (defaults to spec title or 'ApiClient') */
  clientName?: string;
  /** Strategy for grouping routes: 'tags' (default) or 'path' */
  groupingStrategy?: 'tags' | 'path';
  /** Whether to include deprecated endpoints (default: false) */
  includeDeprecated?: boolean;
  /** Path to types file generated by openapi-typescript (optional) */
  typesFile?: string;
  /**
   * Path or function to extract error messages from API error responses
   * Can be a string path (dot notation) or left undefined for auto-detection
   * @example 'data.error.message'
   * @example 'data.errors.0.detail'
   */
  errorMessagePath?: string;
  /**
   * Whether to attempt auto-detection of error message path from OpenAPI spec
   * @default true
   */
  autoDetectErrorPath?: boolean;
}

/**
 * Generate a strongly-typed SDK client from an OpenAPI specification
 *
 * @param options - Configuration options for client generation
 * @throws {Error} When the OpenAPI spec is invalid or generation fails
 *
 * @example
 * ```typescript
 * await generateClient({
 *   openApiSpec: './openapi.json',
 *   outputDir: './src/api-client',
 *   clientName: 'MyApiClient',
 * });
 * ```
 */
export async function generateClient(options: GenerateClientOptions): Promise<void> {
  const {
    openApiSpec,
    outputDir,
    clientName,
    groupingStrategy = 'tags',
    includeDeprecated = false,
    typesFile,
    errorMessagePath,
    autoDetectErrorPath = true,
  } = options;

  try {
    // Extract type names BEFORE dereferencing
    // We need to parse the original spec to get $ref values before they're dereferenced
    let originalSpec: any;
    if (typeof openApiSpec === 'string') {
      const content = await fs.readFile(openApiSpec, 'utf-8');
      if (openApiSpec.endsWith('.yaml') || openApiSpec.endsWith('.yml')) {
        try {
          const yaml = await import('yaml');
          originalSpec = yaml.parse(content);
        } catch (error) {
          // If yaml parsing fails, continue without type extraction
          originalSpec = null;
        }
      } else {
        try {
          originalSpec = JSON.parse(content);
        } catch (error) {
          // If JSON parsing fails, continue without type extraction
          originalSpec = null;
        }
      }
    } else {
      originalSpec = openApiSpec;
    }

    // Extract response type mapping from original spec (before dereferencing)
    // Maps "path:method" to response type name
    const responseTypeMapping = originalSpec
      ? extractResponseTypeMapping(originalSpec)
      : new Map<string, string>();

    // Parse the OpenAPI specification (this will dereference everything)
    const spec = await parseOpenApiSpec(openApiSpec);

    // Extract and validate the specification
    if (!spec.openapi || !spec.paths) {
      throw new Error('Invalid OpenAPI specification: missing openapi version or paths');
    }

    // Generate types using openapi-typescript
    const typesOutputPath = typesFile || join(outputDir, 'types.d.ts');
    let typesGenerated = false;

    try {
      // Ensure output directory exists
      await fs.mkdir(outputDir, { recursive: true });

      // openapi-typescript expects the parsed spec object, not a file path
      // Cast to any to work around type incompatibilities between openapi-types and openapi-typescript
      const ast = await openapiTS(spec as any);
      const typesContent = astToString(ast);
      await fs.writeFile(typesOutputPath, typesContent, 'utf-8');
      typesGenerated = true;
      console.log(`üìÑ Generated types: ${typesOutputPath}`);
    } catch (error) {
      console.warn('‚ö†Ô∏è  Could not generate types with openapi-typescript:', error);
    }

    // Parse and group routes
    const routeGroups = parseRoutes(spec, {
      groupingStrategy,
      includeDeprecated,
    });

    // Determine error message path
    let finalErrorMessagePath = errorMessagePath;

    if (!finalErrorMessagePath && autoDetectErrorPath) {
      // Attempt auto-detection
      const detected = detectErrorMessagePath(spec);
      if (detected) {
        console.log(`üîç Auto-detected error message path: ${detected}`);
        finalErrorMessagePath = detected;
      }
    }

    // Extract and generate custom error types (if any)
    const customErrors = extractCustomErrorSchemas(spec);
    const errorTypes = customErrors.length > 0 ? generateErrorTypes(customErrors) : null;

    // Extract default base URL from spec (first server)
    const defaultBaseURL = spec.servers?.[0]?.url;

    // Generate the main client class
    const clientClass = generateClientClass({
      clientName: clientName || spec.info?.title || 'ApiClient',
      routeGroups,
      typesFile: typesGenerated ? typesOutputPath : undefined,
      defaultBaseURL,
      errorMessagePath: finalErrorMessagePath,
    });

    // Generate route group classes
    const routeGroupClasses = generateRouteGroups(routeGroups, {
      typesFile: typesGenerated ? typesOutputPath : undefined,
      originalSpec: originalSpec, // Pass original spec for per-group type extraction
      responseTypeMapping: responseTypeMapping.size > 0 ? responseTypeMapping : undefined,
    });

    // Write all generated files to the output directory
    await writeGeneratedFiles({
      outputDir,
      clientClass,
      routeGroupClasses,
      clientName: clientName || spec.info?.title || 'ApiClient',
      typesFile: typesGenerated ? typesOutputPath : undefined,
      errorTypes,
    });

    console.log(`‚úÖ Generated SDK client in ${outputDir}`);
    console.log(`üìÅ Client: ${clientName || spec.info?.title || 'ApiClient'}`);
    console.log(`üìÅ Route groups: ${routeGroups.length}`);
    if (typesGenerated) {
      console.log(`üìÅ Types: Generated with openapi-typescript`);
    }
  } catch (error) {
    console.error('‚ùå Failed to generate client:', error);
    throw error;
  }
}
